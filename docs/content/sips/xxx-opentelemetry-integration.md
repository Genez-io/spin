
title = "SIP xxx - OpenTelemetry Integration" template = "main" date = "2022-07-20T13:53:52Z"
---

Summary: Integrate OpenTelemetry into SPIN

Owner: bogdan@genez.io

Created: Jul 20, 2022

Updated: Jul 20, 2022

# Background

Debugging distributed systems can be a very hard task. The current Spin logging system allows the user to log events with different log levels. These logs are then saved in files which can be later inspected. However, if Spin is used in the context of a larger distributed system, the debugging process can become quite cumbersome. An open source standard called OpenTelemetry has emerged to address the problem of observability in distributed systems. For more information about OpenTelemetry, check the documentation [here](https://opentelemetry.io/docs/concepts/observability-primer/).

# Proposal

This SIP proposes to integrate OpenTelemetry tracing in Spin. There are two levels at which the integration will happen:

1.  **Spin code**. Here we discuss about all the helpful observability events that are generated by the Spin infrastructure before and after the WASM component is executed.
    

The proposal here is to start a new span when a trigger is received and end it when the WASM component finishes the execution. The span will contain relevant information such as trigger type and information dependant on the type of the trigger. For example, if the trigger is a HTTP trigger the span will contain the following information:

-   trigger-type: HTTP
    
-   path: the url of the request
    
-   HTTP method: the request’s method
    
-   user-agent
    
-   response status code
    
-   response-content-length
    
-   …
    

**2. The WASM Module itself**. The WASM component should also support OpenTelemetry instrumentation. It is the user’s responsibility to instrument their code and they can use any implementation they find fit. Nevertheless, the data generated has to be exported to a backend. The problem is that the existing OpenTelemetry exporters are using specific HTTP clients that are not available in the WASM module environment. The proposal is to build an exporter that will know how to transfer the OpenTelemetry data from the WASM Module to the outside world. The diagram of the proposed implementation is the following:

![Implementation diagram](https://i.postimg.cc/tRDLPShZ/Untitled-drawio-1.png)

The WASM Module instrumented with OpenTelemetry will produce traces. These traces will be exported outside of the WASM Module using a WIT Interface that has the implementation inside the Spin process. The WIT interface looks like this:

```
record span-context {
    trace-id: list<u8>,
    span-id: u64,
    trace-flags: u8,
    is-remote: bool,
    trace-state: list<tuple<string, string>>
}

enum span-kind {
    /// Indicates that the span describes a request to some remote service. This
    /// span is usually the parent of a remote `SpanKind::Server` span and does
    /// not end until the response is received.
    client,

    /// Indicates that the span covers server-side handling of a synchronous RPC
    /// or other remote request. This span is often the child of a remote
    /// `SpanKind::Client` span that was expected to wait for a response.
    server,

    /// Indicates that the span describes the initiators of an asynchronous
    /// request. This parent span will often end before the corresponding child
    /// `SpanKind::Consumer` span, possibly even before the child span starts.
    ///
    /// In messaging scenarios with batching, tracing individual messages
    /// requires a new `SpanKind::Producer` span per message to be created.
    producer,

    /// Indicates that the span describes a child of an asynchronous
    /// `SpanKind::Producer` request.
    consumer,

    /// Default value.
    ///
    /// Indicates that the span represents an internal operation within an
    /// application, as opposed to an operations with remote parents or
    /// children.
    internal,
}

record event {
    /// The name of this event.
    name: string,

    /// The time at which this event occurred.
    timestamp: u64,

    /// Attributes that describe this event.
    attributes: list<tuple<string, string>>,

    /// The number of attributes that were above the configured limit, and thus
    /// dropped.
    dropped-attributes-count: u32,
}

record link {
    /// The span context of the linked span.
    span-context: span-context,

    /// Attributes that describe this link.
    attributes: list<tuple<string, string>>,

    /// The number of attributes that were above the configured limit, and thus
    /// dropped.
    dropped-attributes-count: u32,
}

enum status {
    /// The default status.
    unset,

    /// The operation contains an error.
    error,

    /// The operation has been validated by an application developer or operator to
    /// have completed successfully.
    ok,
}

record span-resource {
    attrs: list<tuple<string, string>>,
    schema-url: string,
}

record instrumentation-library {
    /// The library name.
    ///
    /// This should be the name of the crate providing the instrumentation.
    name: string,

    /// The library version.
    ///
    /// # Examples
    ///
    /// ```
    /// let library = opentelemetry_api::InstrumentationLibrary::new(
    ///     "my-crate",
    ///     Some(env!("CARGO_PKG_VERSION")),
    ///     None,
    /// );
    /// ```
    version: string,

    /// [Schema url] used by this library.
    ///
    /// [Schema url]: https://github.com/open-telemetry/opentelemetry-specification/blob/v1.9.0/specification/schemas/overview.md#schema-url
    schema-url: string,
}

record span-data {
    span-context: span-context,
    parent-span-id: u64,
    span-kind: span-kind,
    name: string,
    start-time: u64,
    end-time: u64,
    attributes: list<tuple<string, string>>,
    events: list<event>,
    links: list<link>,
    status: status,
    span-resource: span-resource,
    instrumentation-lib: instrumentation-library
}

// The function will be called each time a new span is produced.
receive: func(span-data: span-data) -> bool
```

However, the traces are not sent directly to the Collector because this would imply that the WASM Module would have to be kept alive until all the data is exported successfully. This also could mean that the response returned by the WASM Module might be delayed. To overcome these problems, a buffer is introduced that will implement the WIT Interface and it will batch the data and send it to the Collector. This allows us to decouple the WASM Module from the responsibility of sending the data to Collector and allows it to send the response and finish its execution as soon as possible.

OpenTelemetry supports exporting data to different types of Collectors using various protocols. In this implementation, we will initially only implement the OTLP since this is also enough to support other Collectors since chaining of Collectors in possible.

### Configurations

The user will be able to configure where the data is exported from the Spin’s Application Manifest file (usually named spin.toml). The configuration file will look like this:

```
[[otel]]
otel_exporter_otlp_endpoint="https://.."
otel_resource_attributes="service.name=myService"
sampling_policy="AlwaysOn"|"AlwaysOff"|"ParentBased"|"TraceIdRatioBased"
sampling_policy_parent_based_root_sampler = "AlwaysOn"|"AlwaysOff"|"TraceIdRatioBased"
sampling_policy_raio = <f64>
```

-   **otel_exporter_otlp_endpoint:** the Collector’s endpoint where the traces will be exported
    
-   **otel_resource_attributes:** allows resource attributes to be passed to the SDK at process invocation. Attributes should be in the format key1=value1,key2=value2
    
-   **sampling_policy:** the sampling policy that will be used. There are four possibilities:
    
    1.  AlwaysOn: Always sample the trace
        
    2.  AlwaysOff: Never sample the trace
        
    3.  ParentBased: Respects the parent span's sampling decision or delegates a delegate sampler for root spans. If this option is set, another configuration needs to be set, sampling_policy_parent_based_root_sampler, that will indicate what happens when a root span is started.
        
    4.  TraceIdRatioBased: Sample a given fraction of traces. Fractions >= 1 will always sample. If the parent span is sampled, then its child spans will automatically be sampled. Fractions < 0 are treated as zero, but spans may still be sampled if their parent is. If this option is set, another configuration needs to be set, sampling_policy_raio, which represents the fraction of traces.
        

If no setting is provided, the OpenTelemetry integration will do nothing and all calls with be no-op.

If the HTTP request received by Spin contains the context propagation header (e.g.: TraceContext, Baggage) they will be propagated to the WASM Module.

The implementation will use the open source code of the API and SDK OpenTelemetry available [here](https://github.com/open-telemetry/opentelemetry-rust).

## Future design considerations

-   Do we want to be more granular in configuration and allow the users to set a different Collector for each WASM component?
    
-   If Spin is offered as a SaaS, we need to limit the buffer in order to avoid Out Of Memory errors caused by errors or by a malicious attack.
